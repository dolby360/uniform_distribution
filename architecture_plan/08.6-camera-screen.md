# Step 8.6: Camera Screen with CameraX

## Goal

Implement the CameraScreen with CameraX preview, runtime camera permission handling (via Accompanist Permissions), photo capture, Base64 encoding, and integration with the backend via CameraViewModel. After this step, tapping the FAB on HomeScreen opens the camera, captures a photo, sends it to `/process-outfit`, and navigates to the MatchConfirmation screen with results.

## Prerequisites

- Step 8.5 completed (data layer: models, API, repository)
- Step 8.4 completed (navigation graph with camera stub)
- Emulator running (Step 8.2)

## Files to Create

All under `android/app/src/main/java/com/uniformdist/app/`:

```
ui/screens/camera/
  CameraScreen.kt                # CameraX preview + capture UI
  CameraViewModel.kt             # State management + API call
```

## Files to Modify

```
ui/navigation/NavGraph.kt        # Replace camera stub with real CameraScreen
```

## Key Code

### ui/screens/camera/CameraViewModel.kt

```kotlin
package com.uniformdist.app.ui.screens.camera

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.uniformdist.app.data.model.ProcessOutfitResponse
import com.uniformdist.app.data.repository.OutfitRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class CameraUiState(
    val isProcessing: Boolean = false,
    val result: ProcessOutfitResponse? = null,
    val error: String? = null
)

@HiltViewModel
class CameraViewModel @Inject constructor(
    private val repository: OutfitRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(CameraUiState())
    val uiState: StateFlow<CameraUiState> = _uiState.asStateFlow()

    fun processOutfit(imageBase64: String) {
        viewModelScope.launch {
            _uiState.value = CameraUiState(isProcessing = true)
            try {
                val response = repository.processOutfit(imageBase64)
                _uiState.value = CameraUiState(result = response)
            } catch (e: Exception) {
                _uiState.value = CameraUiState(error = "Failed to process outfit: ${e.message}")
            }
        }
    }

    fun setError(message: String) {
        _uiState.value = CameraUiState(error = message)
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}
```

### ui/screens/camera/CameraScreen.kt

Full CameraX implementation with permission handling, preview, capture, and loading overlay.

```kotlin
package com.uniformdist.app.ui.screens.camera

import android.Manifest
import android.util.Base64
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CameraAlt
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.LocalLifecycleOwner
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.isGranted
import com.google.accompanist.permissions.rememberPermissionState
import com.uniformdist.app.data.model.ProcessOutfitResponse
import java.io.File

@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun CameraScreen(
    onPhotoCaptured: (ProcessOutfitResponse) -> Unit,
    onBack: () -> Unit,
    viewModel: CameraViewModel = hiltViewModel()
) {
    val cameraPermission = rememberPermissionState(Manifest.permission.CAMERA)
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current

    LaunchedEffect(uiState.result) {
        uiState.result?.let { onPhotoCaptured(it) }
    }

    if (!cameraPermission.status.isGranted) {
        // Permission request UI
        Column(
            modifier = Modifier.fillMaxSize(),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text("Camera permission is required")
            Spacer(modifier = Modifier.height(16.dp))
            Button(onClick = { cameraPermission.launchPermissionRequest() }) {
                Text("Grant Permission")
            }
            Spacer(modifier = Modifier.height(8.dp))
            TextButton(onClick = onBack) {
                Text("Go Back")
            }
        }
    } else {
        Box(modifier = Modifier.fillMaxSize()) {
            // CameraX Preview
            val lifecycleOwner = LocalLifecycleOwner.current
            var imageCapture by remember { mutableStateOf<ImageCapture?>(null) }

            AndroidView(
                factory = { ctx ->
                    PreviewView(ctx).also { previewView ->
                        val cameraProviderFuture = ProcessCameraProvider.getInstance(ctx)
                        cameraProviderFuture.addListener({
                            val cameraProvider = cameraProviderFuture.get()
                            val preview = Preview.Builder().build().also {
                                it.surfaceProvider = previewView.surfaceProvider
                            }
                            imageCapture = ImageCapture.Builder()
                                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                                .build()

                            cameraProvider.unbindAll()
                            cameraProvider.bindToLifecycle(
                                lifecycleOwner,
                                CameraSelector.DEFAULT_BACK_CAMERA,
                                preview,
                                imageCapture
                            )
                        }, ContextCompat.getMainExecutor(ctx))
                    }
                },
                modifier = Modifier.fillMaxSize()
            )

            // Capture button
            FloatingActionButton(
                onClick = {
                    val capture = imageCapture ?: return@FloatingActionButton
                    val photoFile = File(context.cacheDir, "outfit_${System.currentTimeMillis()}.jpg")
                    val outputOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()

                    capture.takePicture(
                        outputOptions,
                        ContextCompat.getMainExecutor(context),
                        object : ImageCapture.OnImageSavedCallback {
                            override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                                val bytes = photoFile.readBytes()
                                val base64 = Base64.encodeToString(bytes, Base64.NO_WRAP)
                                viewModel.processOutfit(base64)
                                photoFile.delete()  // clean up temp file
                            }
                            override fun onError(exc: ImageCaptureException) {
                                viewModel.setError("Failed to capture photo: ${exc.message}")
                            }
                        }
                    )
                },
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .padding(32.dp)
            ) {
                Icon(Icons.Default.CameraAlt, contentDescription = "Capture")
            }

            // Loading overlay
            if (uiState.isProcessing) {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.scrim.copy(alpha = 0.5f)
                ) {
                    Box(contentAlignment = Alignment.Center) {
                        Card {
                            Column(
                                modifier = Modifier.padding(32.dp),
                                horizontalAlignment = Alignment.CenterHorizontally
                            ) {
                                CircularProgressIndicator()
                                Spacer(modifier = Modifier.height(16.dp))
                                Text("Analyzing outfit...")
                            }
                        }
                    }
                }
            }

            // Error display
            uiState.error?.let { error ->
                Snackbar(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .padding(16.dp),
                    action = {
                        TextButton(onClick = { viewModel.clearError() }) {
                            Text("Dismiss")
                        }
                    }
                ) {
                    Text(error)
                }
            }
        }
    }
}
```

### NavGraph.kt Update

Replace the Camera stub composable:

```kotlin
// Replace the Camera stub in NavGraph.kt with:
composable(Screen.Camera.route) {
    CameraScreen(
        onPhotoCaptured = { response ->
            // Serialize response to JSON for navigation
            val moshi = com.squareup.moshi.Moshi.Builder()
                .addLast(com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory())
                .build()
            val adapter = moshi.adapter(ProcessOutfitResponse::class.java)
            val json = java.net.URLEncoder.encode(adapter.toJson(response), "UTF-8")
            navController.navigate(Screen.MatchConfirmation.createRoute(json))
        },
        onBack = { navController.popBackStack() }
    )
}
```

## CameraX on Emulator

The Android emulator provides virtual cameras:
- **Back camera**: Shows a moving 3D room scene
- **Front camera**: Shows a checkered pattern

The virtual camera produces valid JPEG images. When sent to the backend:
- Gemini Vision may or may not detect clothing in the synthetic scene
- The flow still validates end-to-end (request is sent, response is received)
- For testing with real clothing detection, use a physical device

## Edge Cases & Troubleshooting

| Issue | Solution |
|-------|----------|
| Camera permission denied permanently | User must grant from Settings; show "Open Settings" button |
| Emulator camera black screen | Restart emulator with `-gpu swiftshader_indirect` |
| Base64 string too large | OkHttp handles large bodies; 60s timeout covers upload |
| `CameraProvider` binding fails | Ensure lifecycle owner is correct; camera might be in use |
| Photo file write fails | Using `cacheDir` which is always writable |
| App crashes on rotation during capture | ViewModel survives config changes; `imageCapture` needs rebinding |
| Accompanist permissions import error | Ensure `accompanist-permissions:0.34.0` in build.gradle.kts |

## Checklist

- [ ] `CameraViewModel.kt` created with `CameraUiState`, `processOutfit()`, `setError()`
- [ ] `CameraScreen.kt` created with:
  - [ ] Camera permission check using Accompanist
  - [ ] Permission request UI with "Grant Permission" button
  - [ ] "Go Back" button when permission not granted
  - [ ] CameraX Preview rendering via `AndroidView`
  - [ ] Image capture on FAB tap
  - [ ] Base64 encoding of captured JPEG
  - [ ] ViewModel call to `processOutfit()`
  - [ ] Loading overlay with `CircularProgressIndicator` + "Analyzing outfit..."
  - [ ] Error display via `Snackbar` with dismiss action
  - [ ] Temp file cleanup after capture
- [ ] `NavGraph.kt` updated: camera stub replaced with real `CameraScreen`
- [ ] Navigation passes `ProcessOutfitResponse` as URL-encoded JSON to MatchConfirmation
- [ ] `./gradlew assembleDebug` â†’ BUILD SUCCESSFUL
- [ ] App installs and launches on emulator
- [ ] Tapping FAB on HomeScreen opens camera screen
- [ ] Camera permission dialog appears (on first launch)
- [ ] After granting permission, camera preview shows emulator virtual scene
- [ ] Tapping capture button takes a photo
- [ ] Loading overlay appears during API processing
- [ ] No crashes in logcat

## Validation Commands

```bash
cd c:/Users/dolev/Downloads/personal/uniform_distribution/android

# 1. Build
./gradlew assembleDebug 2>&1 | tail -3
# Expected: "BUILD SUCCESSFUL"

# 2. Install
adb install -r app/build/outputs/apk/debug/app-debug.apk

# 3. Grant camera permission programmatically (skip dialog)
adb shell pm grant com.uniformdist.app android.permission.CAMERA

# 4. Launch and navigate to camera
adb shell am start -n com.uniformdist.app/.MainActivity
sleep 2

# 5. Verify camera permission is granted
adb shell dumpsys package com.uniformdist.app | grep "CAMERA" | grep "granted=true"
# Expected: shows "granted=true"

# 6. Take screenshot
adb shell screencap -p /sdcard/step_8_6_camera.png
adb pull /sdcard/step_8_6_camera.png ./

# 7. No crashes
adb logcat -d -s AndroidRuntime:E | grep "com.uniformdist" | head -3
# Expected: empty

# 8. Check OkHttp logs for API calls (after capturing photo)
adb logcat -d -s OkHttp:D | tail -20
```
