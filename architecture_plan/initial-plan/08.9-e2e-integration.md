# Step 8.9: End-to-End Integration with Real Backend

## Goal

Test the complete flow against the actual deployed Cloud Functions on GCP. Configure real backend URLs, run the app on the emulator, and write an instrumented test that calls the real API. Verify data flows end-to-end: photo → detection → match/add → Firestore update.

## Prerequisites

- Steps 8.4–8.8 completed (app fully built and unit-tested)
- Backend deployed on GCP (Cloud Functions from Steps 6-7):
  - `process-outfit` (Gen2, us-central1)
  - `confirm-match` (Gen2, us-central1)
  - `add-new-item` (Gen2, us-central1)
- `gcloud` CLI authenticated and configured
- Emulator running (Step 8.2)

## Detailed Actions

### 1. Retrieve Cloud Function URLs

Each Gen2 Cloud Function has its own Cloud Run URL:

```bash
# Get each function URL
PROCESS_URL=$(gcloud functions describe process-outfit \
  --region=us-central1 --gen2 \
  --format="value(serviceConfig.uri)" 2>/dev/null)
echo "Process Outfit: $PROCESS_URL"

CONFIRM_URL=$(gcloud functions describe confirm-match \
  --region=us-central1 --gen2 \
  --format="value(serviceConfig.uri)" 2>/dev/null)
echo "Confirm Match: $CONFIRM_URL"

ADD_URL=$(gcloud functions describe add-new-item \
  --region=us-central1 --gen2 \
  --format="value(serviceConfig.uri)" 2>/dev/null)
echo "Add New Item: $ADD_URL"
```

### 2. Update ApiConfig.kt with Real URLs

Replace the placeholder URLs in `data/api/ApiConfig.kt`:

```kotlin
object ApiConfig {
    const val PROCESS_OUTFIT_URL = "<actual-process-outfit-url>"
    const val CONFIRM_MATCH_URL = "<actual-confirm-match-url>"
    const val ADD_NEW_ITEM_URL = "<actual-add-new-item-url>"
    const val BASE_URL = "https://placeholder.uniform-dist.app/"
    const val TIMEOUT_SECONDS = 60L
}
```

### 3. Test Backend Reachability from Host

```bash
# Quick health check — should return 400 (missing body) not 404 or connection error
curl -s -o /dev/null -w "%{http_code}" -X POST "$PROCESS_URL" \
  -H "Content-Type: application/json" -d '{}'
# Expected: 400 (missing image data)

curl -s -X POST "$PROCESS_URL" \
  -H "Content-Type: application/json" -d '{}' | python -m json.tool
# Expected: {"success": false, "error": "Missing image data"}
```

### 4. Build and Install with Real URLs

```bash
cd c:/Users/dolev/Downloads/personal/uniform_distribution/android
./gradlew assembleDebug
adb install -r app/build/outputs/apk/debug/app-debug.apk
```

### 5. Manual Flow Test via Emulator

```bash
# Launch app
adb shell am start -n com.uniformdist.app/.MainActivity

# Grant camera permission (if not already)
adb shell pm grant com.uniformdist.app android.permission.CAMERA

# Monitor API calls in real-time
adb logcat -s OkHttp:D &

# After capturing a photo via the emulator:
# Watch logcat for request/response logs
```

### 6. Write Instrumented E2E Test

Create a test that calls the real backend API with a small test image.

### Files to Create

```
android/app/src/androidTest/java/com/uniformdist/app/
  EndToEndApiTest.kt               # Instrumented test hitting real backend
```

### EndToEndApiTest.kt

```kotlin
package com.uniformdist.app

import android.util.Base64
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import com.uniformdist.app.data.api.ApiConfig
import com.uniformdist.app.data.model.ProcessOutfitRequest
import com.uniformdist.app.data.model.ProcessOutfitResponse
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import java.util.concurrent.TimeUnit

/**
 * End-to-end test that calls the real backend.
 *
 * Requirements:
 * - Real Cloud Function URLs configured in ApiConfig
 * - Internet access from the test device/emulator
 * - Backend functions deployed and running
 */
@RunWith(AndroidJUnit4::class)
class EndToEndApiTest {

    private lateinit var client: OkHttpClient
    private lateinit var moshi: Moshi

    @Before
    fun setUp() {
        client = OkHttpClient.Builder()
            .connectTimeout(60, TimeUnit.SECONDS)
            .readTimeout(60, TimeUnit.SECONDS)
            .build()

        moshi = Moshi.Builder()
            .addLast(KotlinJsonAdapterFactory())
            .build()
    }

    @Test
    fun testProcessOutfitEndpointReachable() {
        // Send empty request to verify endpoint is reachable
        val body = """{"image": ""}""".toRequestBody("application/json".toMediaType())
        val request = Request.Builder()
            .url(ApiConfig.PROCESS_OUTFIT_URL)
            .post(body)
            .build()

        val response = client.newCall(request).execute()

        // Should get a response (400 or 500, not connection error)
        assertTrue("Backend should be reachable", response.code in 200..599)
    }

    @Test
    fun testProcessOutfitWithMinimalImage() {
        // Create a minimal 1x1 red pixel JPEG as test image
        // This tiny image won't detect clothing, but validates the API flow
        val context = InstrumentationRegistry.getInstrumentation().targetContext

        // Create a minimal test image programmatically
        val bitmap = android.graphics.Bitmap.createBitmap(100, 100, android.graphics.Bitmap.Config.ARGB_8888)
        val canvas = android.graphics.Canvas(bitmap)
        canvas.drawColor(android.graphics.Color.BLUE)  // solid blue image
        val stream = java.io.ByteArrayOutputStream()
        bitmap.compress(android.graphics.Bitmap.CompressFormat.JPEG, 50, stream)
        val imageBase64 = Base64.encodeToString(stream.toByteArray(), Base64.NO_WRAP)

        // Send to process-outfit
        val adapter = moshi.adapter(ProcessOutfitRequest::class.java)
        val requestBody = adapter.toJson(ProcessOutfitRequest(image = imageBase64))
            .toRequestBody("application/json".toMediaType())

        val request = Request.Builder()
            .url(ApiConfig.PROCESS_OUTFIT_URL)
            .post(requestBody)
            .build()

        val response = client.newCall(request).execute()
        val responseBody = response.body?.string()

        assertNotNull("Response body should not be null", responseBody)

        // Parse response
        val responseAdapter = moshi.adapter(ProcessOutfitResponse::class.java)
        val processResponse = responseAdapter.fromJson(responseBody!!)

        assertNotNull("Should parse response", processResponse)
        // The API may return success=true but with null shirt/pants (nothing detected in solid blue image)
        // OR success=false with an error — both are valid responses
        // What matters is the endpoint responded correctly
    }

    @Test
    fun testConfirmMatchEndpointReachable() {
        val body = """{}""".toRequestBody("application/json".toMediaType())
        val request = Request.Builder()
            .url(ApiConfig.CONFIRM_MATCH_URL)
            .post(body)
            .build()

        val response = client.newCall(request).execute()
        val responseBody = response.body?.string() ?: ""

        // Should get 400 (missing fields) not connection error
        assertEquals("Should return 400 for missing fields", 400, response.code)
        assertTrue("Error should mention missing fields", responseBody.contains("Missing"))
    }

    @Test
    fun testAddNewItemEndpointReachable() {
        val body = """{}""".toRequestBody("application/json".toMediaType())
        val request = Request.Builder()
            .url(ApiConfig.ADD_NEW_ITEM_URL)
            .post(body)
            .build()

        val response = client.newCall(request).execute()
        val responseBody = response.body?.string() ?: ""

        assertEquals("Should return 400 for missing fields", 400, response.code)
        assertTrue("Error should mention missing fields", responseBody.contains("Missing"))
    }
}
```

### 7. Run Instrumented Tests

```bash
cd c:/Users/dolev/Downloads/personal/uniform_distribution/android

# Run on the connected emulator
./gradlew connectedAndroidTest 2>&1 | tail -20
```

### 8. Verify Firestore Updates (Optional)

After a successful confirm-match or add-new-item, verify the data landed in Firestore:

```bash
# List recent wear logs
gcloud firestore documents list \
  --database="(default)" \
  --collection-path="wear_logs" \
  --limit=5

# List clothing items
gcloud firestore documents list \
  --database="(default)" \
  --collection-path="clothing_items" \
  --limit=5
```

## What to Expect from Emulator Testing

| Scenario | Expected Behavior |
|----------|-------------------|
| Capture emulator virtual camera scene | Valid JPEG captured and base64 encoded |
| Send to `/process-outfit` | Response received (may be success with no detection, or success with false-positive detection) |
| Gemini Vision on synthetic image | May not detect shirt/pants → response has `null` shirt/pants |
| Confirm match (if detected) | `/confirm-match` updates Firestore wear_count |
| Add new item (if not matched) | `/add-new-item` creates new Firestore document |

**Key Point**: The emulator's virtual camera produces synthetic images. Gemini Vision may or may not detect clothing in these images. The integration test validates the **API flow** (request → response → data persistence), not clothing detection accuracy.

## Edge Cases & Troubleshooting

| Issue | Solution |
|-------|----------|
| Cloud Function cold start (10-30s delay) | First call may be slow; 60s timeout covers this |
| `CERTIFICATE_VERIFY_FAILED` from emulator | Emulator uses host's SSL; should work. If not, check system time |
| Functions return `Permission Denied` | Verify `--allow-unauthenticated` flag in deploy.sh |
| Instrumented test timeout | Increase `@Test(timeout = 120000)` for slow network |
| Emulator no internet | Check emulator DNS: `adb shell ping google.com` |
| Firestore quota exceeded | Free tier: 50K reads/day, 20K writes/day — should be fine for testing |
| Functions not deployed | Run `cd backend && ./deploy.sh` first |

## Checklist

- [ ] Cloud Function URLs retrieved via `gcloud functions describe`
- [ ] `ApiConfig.kt` updated with real URLs for all 3 functions
- [ ] Backend reachable from host machine (curl test returns 400/200, not connection error)
- [ ] App built and installed with real URLs
- [ ] App launches on emulator with no crashes
- [ ] `EndToEndApiTest.kt` created with:
  - [ ] Process outfit endpoint reachability test
  - [ ] Process outfit with minimal test image
  - [ ] Confirm match endpoint reachability test
  - [ ] Add new item endpoint reachability test
- [ ] `./gradlew connectedAndroidTest` → ALL TESTS PASS
- [ ] OkHttp logcat shows successful API request/response cycle
- [ ] No `FATAL` errors in logcat during E2E flow
- [ ] (Optional) Firestore shows new entries after successful operations

## Validation Commands

```bash
cd c:/Users/dolev/Downloads/personal/uniform_distribution/android

# 1. Run instrumented tests
./gradlew connectedAndroidTest 2>&1 | tail -20
# Expected: "BUILD SUCCESSFUL" with all tests passing

# 2. Check logcat for API calls
adb logcat -d -s OkHttp:D | grep -E "POST|200|400|500" | tail -10

# 3. Check for crashes
adb logcat -d -s AndroidRuntime:E | grep "com.uniformdist" | head -3
# Expected: empty

# 4. View instrumented test report
echo "Report: android/app/build/reports/androidTests/connected/index.html"

# 5. Verify Firestore (optional)
gcloud firestore documents list --collection-path="wear_logs" --limit=3
```
