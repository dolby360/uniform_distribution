# Step 8.5: Data Layer (Models, API, DI, Repository)

## Goal

Implement the full networking layer: Moshi data models for all API request/response types, Retrofit API interface, Hilt dependency injection for networking, and the OutfitRepository. Solve the multi-URL Cloud Functions issue with an OkHttp interceptor.

## Prerequisites

- Step 8.4 completed (app shell compiles and launches)

## Backend API Reference

The backend deploys 3 separate Cloud Functions (Gen2), each with its own URL:

| Function | Entry Point | Method | Timeout | Memory |
|----------|-------------|--------|---------|--------|
| `process-outfit` | `process_outfit` | POST | 60s | 1GB |
| `confirm-match` | `confirm_match_handler` | POST | 10s | 256MB |
| `add-new-item` | `add_new_item_handler` | POST | 10s | 256MB |

### Request/Response Contracts

**POST /process-outfit**
```json
// Request
{ "image": "<base64-encoded-jpeg>" }

// Response (success)
{
  "success": true,
  "original_photo_url": "gs://...",
  "shirt": {
    "matched": true,
    "item_id": "abc123",
    "similarity": 0.92,
    "image_url": "https://signed-url...",
    "cropped_url": "https://signed-url...",
    "embedding": [0.1, 0.2, ...]
  },
  "pants": { ... }  // same structure, or null
}
```

**POST /confirm-match**
```json
// Request
{ "item_id": "abc123", "item_type": "shirt", "original_photo_url": "gs://...", "similarity_score": 0.92 }

// Response
{ "success": true, "item_id": "abc123", "wear_count": 5, "last_worn": "2024-01-15T10:30:00Z" }
```

**POST /add-new-item**
```json
// Request
{ "item_type": "pants", "cropped_image_url": "gs://...", "embedding": [...], "original_photo_url": "gs://...", "log_wear": true }

// Response
{ "success": true, "item_id": "new_item_456" }
```

## Files to Create

All under `android/app/src/main/java/com/uniformdist/app/`:

```
data/
  api/
    ApiConfig.kt                  # Base URLs for all Cloud Functions
    UniformDistApi.kt             # Retrofit interface
  model/
    Models.kt                     # All request/response data classes
  repository/
    OutfitRepository.kt           # Repository wrapping API calls
di/
  NetworkModule.kt                # Hilt module: Moshi, OkHttp, Retrofit, API
```

## Key Code

### data/api/ApiConfig.kt

Handles the multi-URL issue: each Cloud Function gets its own URL.

```kotlin
package com.uniformdist.app.data.api

object ApiConfig {
    // Each Gen2 Cloud Function has its own Cloud Run URL
    // Replace these with actual deployed URLs from:
    //   gcloud functions describe <name> --region=us-central1 --gen2 --format="value(serviceConfig.uri)"
    const val PROCESS_OUTFIT_URL = "https://process-outfit-XXXXX-uc.a.run.app"
    const val CONFIRM_MATCH_URL = "https://confirm-match-XXXXX-uc.a.run.app"
    const val ADD_NEW_ITEM_URL = "https://add-new-item-XXXXX-uc.a.run.app"

    // Retrofit needs a base URL even though we override per-request
    // Using a placeholder that gets overridden by the interceptor
    const val BASE_URL = "https://placeholder.uniform-dist.app/"

    const val TIMEOUT_SECONDS = 60L
}
```

### data/api/UniformDistApi.kt

Uses `@Url` to override the base URL per-endpoint:

```kotlin
package com.uniformdist.app.data.api

import com.uniformdist.app.data.model.*
import retrofit2.http.Body
import retrofit2.http.POST
import retrofit2.http.Url

interface UniformDistApi {

    @POST
    suspend fun processOutfit(
        @Url url: String = ApiConfig.PROCESS_OUTFIT_URL,
        @Body request: ProcessOutfitRequest
    ): ProcessOutfitResponse

    @POST
    suspend fun confirmMatch(
        @Url url: String = ApiConfig.CONFIRM_MATCH_URL,
        @Body request: ConfirmMatchRequest
    ): ConfirmMatchResponse

    @POST
    suspend fun addNewItem(
        @Url url: String = ApiConfig.ADD_NEW_ITEM_URL,
        @Body request: AddNewItemRequest
    ): AddNewItemResponse
}
```

### data/model/Models.kt

All request/response data classes in one file:

```kotlin
package com.uniformdist.app.data.model

import com.squareup.moshi.JsonClass

// --- Process Outfit ---

@JsonClass(generateAdapter = true)
data class ProcessOutfitRequest(
    val image: String  // base64-encoded JPEG
)

@JsonClass(generateAdapter = true)
data class ItemMatchResult(
    val matched: Boolean,
    val item_id: String? = null,
    val similarity: Double? = null,
    val image_url: String? = null,
    val cropped_url: String? = null,
    val embedding: List<Double>? = null
)

@JsonClass(generateAdapter = true)
data class ProcessOutfitResponse(
    val success: Boolean,
    val shirt: ItemMatchResult? = null,
    val pants: ItemMatchResult? = null,
    val original_photo_url: String? = null,
    val error: String? = null
)

// --- Confirm Match ---

@JsonClass(generateAdapter = true)
data class ConfirmMatchRequest(
    val item_id: String,
    val item_type: String,
    val original_photo_url: String,
    val similarity_score: Double? = null
)

@JsonClass(generateAdapter = true)
data class ConfirmMatchResponse(
    val success: Boolean,
    val item_id: String,
    val wear_count: Int,
    val last_worn: String? = null
)

// --- Add New Item ---

@JsonClass(generateAdapter = true)
data class AddNewItemRequest(
    val item_type: String,
    val cropped_image_url: String,
    val embedding: List<Double>,
    val original_photo_url: String,
    val log_wear: Boolean
)

@JsonClass(generateAdapter = true)
data class AddNewItemResponse(
    val success: Boolean,
    val item_id: String
)
```

### di/NetworkModule.kt

```kotlin
package com.uniformdist.app.di

import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import com.uniformdist.app.data.api.ApiConfig
import com.uniformdist.app.data.api.UniformDistApi
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory
import java.util.concurrent.TimeUnit
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun provideMoshi(): Moshi = Moshi.Builder()
        .addLast(KotlinJsonAdapterFactory())
        .build()

    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient = OkHttpClient.Builder()
        .connectTimeout(ApiConfig.TIMEOUT_SECONDS, TimeUnit.SECONDS)
        .readTimeout(ApiConfig.TIMEOUT_SECONDS, TimeUnit.SECONDS)
        .writeTimeout(ApiConfig.TIMEOUT_SECONDS, TimeUnit.SECONDS)
        .addInterceptor(HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BASIC
        })
        .build()

    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient, moshi: Moshi): Retrofit =
        Retrofit.Builder()
            .baseUrl(ApiConfig.BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(MoshiConverterFactory.create(moshi))
            .build()

    @Provides
    @Singleton
    fun provideApi(retrofit: Retrofit): UniformDistApi =
        retrofit.create(UniformDistApi::class.java)
}
```

**Note**: Logging level is `BASIC` (not `BODY`) to avoid logging huge base64 image payloads.

### data/repository/OutfitRepository.kt

```kotlin
package com.uniformdist.app.data.repository

import com.uniformdist.app.data.api.UniformDistApi
import com.uniformdist.app.data.model.*
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class OutfitRepository @Inject constructor(
    private val api: UniformDistApi
) {
    suspend fun processOutfit(imageBase64: String): ProcessOutfitResponse {
        return api.processOutfit(request = ProcessOutfitRequest(image = imageBase64))
    }

    suspend fun confirmMatch(
        itemId: String,
        itemType: String,
        originalPhotoUrl: String,
        similarityScore: Double? = null
    ): ConfirmMatchResponse {
        return api.confirmMatch(
            request = ConfirmMatchRequest(
                item_id = itemId,
                item_type = itemType,
                original_photo_url = originalPhotoUrl,
                similarity_score = similarityScore
            )
        )
    }

    suspend fun addNewItem(
        itemType: String,
        croppedImageUrl: String,
        embedding: List<Double>,
        originalPhotoUrl: String,
        logWear: Boolean
    ): AddNewItemResponse {
        return api.addNewItem(
            request = AddNewItemRequest(
                item_type = itemType,
                cropped_image_url = croppedImageUrl,
                embedding = embedding,
                original_photo_url = originalPhotoUrl,
                log_wear = logWear
            )
        )
    }
}
```

## Multi-URL Design Decision

The backend deploys 3 separate Cloud Functions with different URLs (e.g., `https://process-outfit-xxxxx-uc.a.run.app`). Instead of using a single `BASE_URL` with path-based routing (which doesn't work for separate Cloud Functions), we use Retrofit's `@Url` parameter to override the full URL per-endpoint. The `BASE_URL` is a placeholder required by Retrofit's builder but is never actually used.

## Edge Cases & Troubleshooting

| Issue | Solution |
|-------|----------|
| Moshi codegen not generating adapters | Ensure `ksp("com.squareup.moshi:moshi-kotlin-codegen:1.15.0")` is in build.gradle |
| `KotlinJsonAdapterFactory` vs codegen | Both work; codegen is faster, KotlinJsonAdapterFactory is fallback |
| Base64 image too large for OkHttp | OkHttp handles large bodies; 60s timeout accounts for upload time |
| Retrofit `@Url` overrides base URL | Intended behavior — each function has its own full URL |
| `@JsonClass` field name mismatch | Field names must match backend JSON keys exactly (snake_case) |
| Hilt injection fails | Ensure `@Module @InstallIn(SingletonComponent::class)` on NetworkModule |

## Checklist

- [ ] `data/model/Models.kt` created with all 7 data classes:
  - [ ] `ProcessOutfitRequest`
  - [ ] `ItemMatchResult`
  - [ ] `ProcessOutfitResponse`
  - [ ] `ConfirmMatchRequest`
  - [ ] `ConfirmMatchResponse`
  - [ ] `AddNewItemRequest`
  - [ ] `AddNewItemResponse`
- [ ] All data classes have `@JsonClass(generateAdapter = true)`
- [ ] Field names match backend JSON keys (snake_case: `item_id`, `item_type`, etc.)
- [ ] `data/api/ApiConfig.kt` created with all 3 Cloud Function URLs + timeout
- [ ] `data/api/UniformDistApi.kt` created with 3 endpoints using `@Url`
- [ ] `di/NetworkModule.kt` created providing Moshi, OkHttpClient, Retrofit, and API
- [ ] `data/repository/OutfitRepository.kt` created wrapping all 3 API calls
- [ ] `./gradlew assembleDebug` → BUILD SUCCESSFUL
- [ ] KSP generates Moshi adapters (check `app/build/generated/ksp/`)
- [ ] No new crashes when launching the app
- [ ] OkHttp logging level is `BASIC` (not `BODY` — avoids logging base64 images)

## Validation Commands

```bash
cd c:/Users/dolev/Downloads/personal/uniform_distribution/android

# 1. Build with data layer
./gradlew assembleDebug 2>&1 | tail -3
# Expected: "BUILD SUCCESSFUL"

# 2. Moshi adapters generated by KSP
find app/build/generated/ksp -name "*JsonAdapter*" 2>/dev/null | head -5
# Expected: adapter files for each @JsonClass model

# 3. App still launches fine
adb install -r app/build/outputs/apk/debug/app-debug.apk
adb shell am start -n com.uniformdist.app/.MainActivity
sleep 2
adb shell pidof com.uniformdist.app
# Expected: PID (app running)

# 4. No crashes
adb logcat -d -s AndroidRuntime:E | grep "com.uniformdist" | head -3
# Expected: empty
```
