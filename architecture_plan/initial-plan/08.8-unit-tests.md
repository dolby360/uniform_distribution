# Step 8.8: Unit Tests + Mock Backend

## Goal

Write comprehensive unit tests for the data layer (model serialization, repository) and ViewModels (CameraViewModel, MatchConfirmationViewModel) using MockWebServer to simulate backend responses without hitting the real API. All tests run via `./gradlew test`.

## Prerequisites

- Steps 8.4–8.7 completed (all app code compiles)
- Test dependencies already in `app/build.gradle.kts` (added in Step 8.3):
  - `junit:junit:4.13.2`
  - `mockito-core:5.8.0` + `mockito-kotlin:5.2.1`
  - `kotlinx-coroutines-test:1.7.3`
  - `mockwebserver:4.12.0`
  - `core-testing:2.2.0`

## Files to Create

All under `android/app/src/test/java/com/uniformdist/app/`:

```
data/model/
  ModelSerializationTest.kt        # Moshi JSON ↔ model roundtrip tests
data/repository/
  OutfitRepositoryTest.kt          # Repository with mocked API
ui/screens/camera/
  CameraViewModelTest.kt           # ViewModel state transitions
ui/screens/confirmation/
  MatchConfirmationViewModelTest.kt # Confirm/add flow tests
```

## Key Code

### data/model/ModelSerializationTest.kt

Tests that all Moshi models serialize/deserialize correctly and field names match the backend's snake_case JSON.

```kotlin
package com.uniformdist.app.data.model

import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

class ModelSerializationTest {

    private lateinit var moshi: Moshi

    @Before
    fun setUp() {
        moshi = Moshi.Builder()
            .addLast(KotlinJsonAdapterFactory())
            .build()
    }

    @Test
    fun `ProcessOutfitRequest serializes correctly`() {
        val request = ProcessOutfitRequest(image = "base64data")
        val adapter = moshi.adapter(ProcessOutfitRequest::class.java)
        val json = adapter.toJson(request)

        assertTrue(json.contains("\"image\""))
        assertTrue(json.contains("\"base64data\""))
    }

    @Test
    fun `ProcessOutfitResponse deserializes with matched shirt`() {
        val json = """
        {
            "success": true,
            "original_photo_url": "gs://bucket/photo.jpg",
            "shirt": {
                "matched": true,
                "item_id": "shirt_001",
                "similarity": 0.92,
                "image_url": "https://example.com/shirt.jpg",
                "cropped_url": "https://example.com/cropped.jpg",
                "embedding": [0.1, 0.2, 0.3]
            },
            "pants": null
        }
        """.trimIndent()

        val adapter = moshi.adapter(ProcessOutfitResponse::class.java)
        val response = adapter.fromJson(json)

        assertNotNull(response)
        assertTrue(response!!.success)
        assertEquals("gs://bucket/photo.jpg", response.original_photo_url)
        assertNotNull(response.shirt)
        assertTrue(response.shirt!!.matched)
        assertEquals("shirt_001", response.shirt!!.item_id)
        assertEquals(0.92, response.shirt!!.similarity!!, 0.01)
        assertNull(response.pants)
    }

    @Test
    fun `ProcessOutfitResponse deserializes with new item (unmatched)`() {
        val json = """
        {
            "success": true,
            "original_photo_url": "gs://bucket/photo.jpg",
            "shirt": {
                "matched": false,
                "cropped_url": "https://example.com/cropped.jpg",
                "embedding": [0.1, 0.2, 0.3]
            },
            "pants": {
                "matched": true,
                "item_id": "pants_002",
                "similarity": 0.88,
                "image_url": "https://example.com/pants.jpg"
            }
        }
        """.trimIndent()

        val adapter = moshi.adapter(ProcessOutfitResponse::class.java)
        val response = adapter.fromJson(json)

        assertNotNull(response)
        assertFalse(response!!.shirt!!.matched)
        assertNull(response.shirt!!.item_id)
        assertTrue(response.pants!!.matched)
        assertEquals("pants_002", response.pants!!.item_id)
    }

    @Test
    fun `ProcessOutfitResponse deserializes error response`() {
        val json = """
        {
            "success": false,
            "error": "Missing image data"
        }
        """.trimIndent()

        val adapter = moshi.adapter(ProcessOutfitResponse::class.java)
        val response = adapter.fromJson(json)

        assertNotNull(response)
        assertFalse(response!!.success)
        assertEquals("Missing image data", response.error)
        assertNull(response.shirt)
        assertNull(response.pants)
    }

    @Test
    fun `ConfirmMatchRequest serializes with snake_case fields`() {
        val request = ConfirmMatchRequest(
            item_id = "abc123",
            item_type = "shirt",
            original_photo_url = "gs://bucket/photo.jpg",
            similarity_score = 0.95
        )
        val adapter = moshi.adapter(ConfirmMatchRequest::class.java)
        val json = adapter.toJson(request)

        assertTrue(json.contains("\"item_id\""))
        assertTrue(json.contains("\"item_type\""))
        assertTrue(json.contains("\"original_photo_url\""))
        assertTrue(json.contains("\"similarity_score\""))
    }

    @Test
    fun `ConfirmMatchResponse deserializes correctly`() {
        val json = """
        {
            "success": true,
            "item_id": "abc123",
            "wear_count": 5,
            "last_worn": "2024-01-15T10:30:00Z"
        }
        """.trimIndent()

        val adapter = moshi.adapter(ConfirmMatchResponse::class.java)
        val response = adapter.fromJson(json)

        assertNotNull(response)
        assertTrue(response!!.success)
        assertEquals("abc123", response.item_id)
        assertEquals(5, response.wear_count)
    }

    @Test
    fun `AddNewItemRequest serializes correctly`() {
        val request = AddNewItemRequest(
            item_type = "pants",
            cropped_image_url = "gs://bucket/cropped.jpg",
            embedding = listOf(0.1, 0.2, 0.3),
            original_photo_url = "gs://bucket/photo.jpg",
            log_wear = true
        )
        val adapter = moshi.adapter(AddNewItemRequest::class.java)
        val json = adapter.toJson(request)

        assertTrue(json.contains("\"item_type\""))
        assertTrue(json.contains("\"cropped_image_url\""))
        assertTrue(json.contains("\"embedding\""))
        assertTrue(json.contains("\"log_wear\""))
        assertTrue(json.contains("true"))
    }

    @Test
    fun `AddNewItemResponse deserializes correctly`() {
        val json = """
        {
            "success": true,
            "item_id": "new_item_456"
        }
        """.trimIndent()

        val adapter = moshi.adapter(AddNewItemResponse::class.java)
        val response = adapter.fromJson(json)

        assertNotNull(response)
        assertTrue(response!!.success)
        assertEquals("new_item_456", response.item_id)
    }

    @Test
    fun `ProcessOutfitResponse roundtrip serialize-deserialize`() {
        val original = ProcessOutfitResponse(
            success = true,
            shirt = ItemMatchResult(
                matched = true,
                item_id = "s1",
                similarity = 0.95,
                image_url = "https://img.com/s1.jpg"
            ),
            pants = ItemMatchResult(
                matched = false,
                cropped_url = "https://img.com/p_crop.jpg",
                embedding = listOf(0.1, 0.2)
            ),
            original_photo_url = "gs://bucket/photo.jpg"
        )

        val adapter = moshi.adapter(ProcessOutfitResponse::class.java)
        val json = adapter.toJson(original)
        val deserialized = adapter.fromJson(json)

        assertEquals(original, deserialized)
    }
}
```

### data/repository/OutfitRepositoryTest.kt

```kotlin
package com.uniformdist.app.data.repository

import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import com.uniformdist.app.data.api.UniformDistApi
import com.uniformdist.app.data.model.*
import kotlinx.coroutines.test.runTest
import okhttp3.mockwebserver.MockResponse
import okhttp3.mockwebserver.MockWebServer
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory

class OutfitRepositoryTest {

    private lateinit var mockWebServer: MockWebServer
    private lateinit var api: UniformDistApi
    private lateinit var repository: OutfitRepository

    @Before
    fun setUp() {
        mockWebServer = MockWebServer()
        mockWebServer.start()

        val moshi = Moshi.Builder()
            .addLast(KotlinJsonAdapterFactory())
            .build()

        api = Retrofit.Builder()
            .baseUrl(mockWebServer.url("/"))
            .addConverterFactory(MoshiConverterFactory.create(moshi))
            .build()
            .create(UniformDistApi::class.java)

        repository = OutfitRepository(api)
    }

    @After
    fun tearDown() {
        mockWebServer.shutdown()
    }

    @Test
    fun `processOutfit returns successful response with match`() = runTest {
        val responseBody = """
        {
            "success": true,
            "original_photo_url": "gs://bucket/photo.jpg",
            "shirt": {
                "matched": true,
                "item_id": "shirt_001",
                "similarity": 0.92,
                "image_url": "https://example.com/shirt.jpg"
            }
        }
        """.trimIndent()

        mockWebServer.enqueue(MockResponse().setBody(responseBody).setResponseCode(200))

        val result = repository.processOutfit("base64ImageData")

        assertTrue(result.success)
        assertNotNull(result.shirt)
        assertTrue(result.shirt!!.matched)
        assertEquals("shirt_001", result.shirt!!.item_id)
    }

    @Test
    fun `confirmMatch returns updated wear count`() = runTest {
        val responseBody = """
        {
            "success": true,
            "item_id": "abc123",
            "wear_count": 5,
            "last_worn": "2024-01-15T10:30:00Z"
        }
        """.trimIndent()

        mockWebServer.enqueue(MockResponse().setBody(responseBody).setResponseCode(200))

        val result = repository.confirmMatch(
            itemId = "abc123",
            itemType = "shirt",
            originalPhotoUrl = "gs://bucket/photo.jpg",
            similarityScore = 0.92
        )

        assertTrue(result.success)
        assertEquals(5, result.wear_count)
    }

    @Test
    fun `addNewItem returns new item id`() = runTest {
        val responseBody = """
        {
            "success": true,
            "item_id": "new_item_456"
        }
        """.trimIndent()

        mockWebServer.enqueue(MockResponse().setBody(responseBody).setResponseCode(200))

        val result = repository.addNewItem(
            itemType = "pants",
            croppedImageUrl = "gs://bucket/cropped.jpg",
            embedding = listOf(0.1, 0.2, 0.3),
            originalPhotoUrl = "gs://bucket/photo.jpg",
            logWear = true
        )

        assertTrue(result.success)
        assertEquals("new_item_456", result.item_id)
    }

    @Test(expected = Exception::class)
    fun `processOutfit throws on server error`() = runTest {
        mockWebServer.enqueue(MockResponse().setResponseCode(500).setBody("Internal Server Error"))
        repository.processOutfit("base64ImageData")
    }

    @Test
    fun `processOutfit sends correct request body`() = runTest {
        mockWebServer.enqueue(
            MockResponse().setBody("""{"success":true}""").setResponseCode(200)
        )

        repository.processOutfit("testBase64Data")

        val request = mockWebServer.takeRequest()
        assertTrue(request.body.readUtf8().contains("\"image\":\"testBase64Data\""))
    }
}
```

### ui/screens/camera/CameraViewModelTest.kt

```kotlin
package com.uniformdist.app.ui.screens.camera

import com.uniformdist.app.data.model.*
import com.uniformdist.app.data.repository.OutfitRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.*
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever

@OptIn(ExperimentalCoroutinesApi::class)
class CameraViewModelTest {

    private val testDispatcher = StandardTestDispatcher()
    private lateinit var repository: OutfitRepository
    private lateinit var viewModel: CameraViewModel

    @Before
    fun setUp() {
        Dispatchers.setMain(testDispatcher)
        repository = mock()
        viewModel = CameraViewModel(repository)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    @Test
    fun `initial state is idle`() {
        val state = viewModel.uiState.value
        assertFalse(state.isProcessing)
        assertNull(state.result)
        assertNull(state.error)
    }

    @Test
    fun `processOutfit sets isProcessing to true`() = runTest {
        whenever(repository.processOutfit("img")).thenReturn(
            ProcessOutfitResponse(success = true)
        )

        viewModel.processOutfit("img")

        // Before coroutine completes
        assertTrue(viewModel.uiState.value.isProcessing)

        // After coroutine completes
        advanceUntilIdle()
        assertFalse(viewModel.uiState.value.isProcessing)
        assertNotNull(viewModel.uiState.value.result)
    }

    @Test
    fun `processOutfit success sets result`() = runTest {
        val expectedResponse = ProcessOutfitResponse(
            success = true,
            shirt = ItemMatchResult(matched = true, item_id = "s1", similarity = 0.9)
        )
        whenever(repository.processOutfit("img")).thenReturn(expectedResponse)

        viewModel.processOutfit("img")
        advanceUntilIdle()

        assertEquals(expectedResponse, viewModel.uiState.value.result)
        assertNull(viewModel.uiState.value.error)
    }

    @Test
    fun `processOutfit failure sets error`() = runTest {
        whenever(repository.processOutfit("img")).thenThrow(RuntimeException("Network error"))

        viewModel.processOutfit("img")
        advanceUntilIdle()

        assertNull(viewModel.uiState.value.result)
        assertTrue(viewModel.uiState.value.error!!.contains("Network error"))
    }

    @Test
    fun `setError updates error state`() {
        viewModel.setError("Camera failed")
        assertEquals("Camera failed", viewModel.uiState.value.error)
    }

    @Test
    fun `clearError clears error state`() {
        viewModel.setError("Some error")
        viewModel.clearError()
        assertNull(viewModel.uiState.value.error)
    }
}
```

### ui/screens/confirmation/MatchConfirmationViewModelTest.kt

```kotlin
package com.uniformdist.app.ui.screens.confirmation

import androidx.lifecycle.SavedStateHandle
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import com.uniformdist.app.data.model.*
import com.uniformdist.app.data.repository.OutfitRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.*
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.mockito.kotlin.any
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever
import java.net.URLEncoder

@OptIn(ExperimentalCoroutinesApi::class)
class MatchConfirmationViewModelTest {

    private val testDispatcher = StandardTestDispatcher()
    private lateinit var repository: OutfitRepository
    private val moshi = Moshi.Builder().addLast(KotlinJsonAdapterFactory()).build()

    @Before
    fun setUp() {
        Dispatchers.setMain(testDispatcher)
        repository = mock()
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    private fun createViewModel(response: ProcessOutfitResponse): MatchConfirmationViewModel {
        val adapter = moshi.adapter(ProcessOutfitResponse::class.java)
        val json = URLEncoder.encode(adapter.toJson(response), "UTF-8")
        val savedStateHandle = SavedStateHandle(mapOf("resultJson" to json))
        return MatchConfirmationViewModel(savedStateHandle, repository)
    }

    @Test
    fun `initializes with match results from navigation`() {
        val response = ProcessOutfitResponse(
            success = true,
            shirt = ItemMatchResult(matched = true, item_id = "s1", similarity = 0.9),
            pants = ItemMatchResult(matched = false, cropped_url = "url")
        )

        val viewModel = createViewModel(response)

        assertNotNull(viewModel.uiState.value.matchResults)
        assertEquals("s1", viewModel.uiState.value.matchResults?.shirt?.item_id)
        assertFalse(viewModel.uiState.value.isDone)
    }

    @Test
    fun `isDone when no items detected`() {
        val response = ProcessOutfitResponse(success = true, shirt = null, pants = null)
        val viewModel = createViewModel(response)

        assertTrue(viewModel.uiState.value.isDone)
    }

    @Test
    fun `isDone after handling both items`() = runTest {
        val response = ProcessOutfitResponse(
            success = true,
            shirt = ItemMatchResult(matched = true, item_id = "s1", similarity = 0.9),
            pants = ItemMatchResult(matched = true, item_id = "p1", similarity = 0.85),
            original_photo_url = "gs://photo.jpg"
        )

        whenever(repository.confirmMatch(any(), any(), any(), any())).thenReturn(
            ConfirmMatchResponse(success = true, item_id = "s1", wear_count = 1)
        )

        val viewModel = createViewModel(response)

        viewModel.confirmMatch("shirt", response.shirt!!)
        advanceUntilIdle()
        assertTrue(viewModel.uiState.value.shirtHandled)
        assertFalse(viewModel.uiState.value.isDone)

        viewModel.confirmMatch("pants", response.pants!!)
        advanceUntilIdle()
        assertTrue(viewModel.uiState.value.pantsHandled)
        assertTrue(viewModel.uiState.value.isDone)
    }

    @Test
    fun `confirmMatch error sets error state`() = runTest {
        val response = ProcessOutfitResponse(
            success = true,
            shirt = ItemMatchResult(matched = true, item_id = "s1", similarity = 0.9),
            original_photo_url = "gs://photo.jpg"
        )

        whenever(repository.confirmMatch(any(), any(), any(), any()))
            .thenThrow(RuntimeException("Network error"))

        val viewModel = createViewModel(response)
        viewModel.confirmMatch("shirt", response.shirt!!)
        advanceUntilIdle()

        assertNotNull(viewModel.uiState.value.error)
        assertTrue(viewModel.uiState.value.error!!.contains("Network error"))
        assertFalse(viewModel.uiState.value.shirtHandled)
    }

    @Test
    fun `addNewItem calls repository with correct data`() = runTest {
        val response = ProcessOutfitResponse(
            success = true,
            pants = ItemMatchResult(
                matched = false,
                cropped_url = "gs://cropped.jpg",
                embedding = listOf(0.1, 0.2)
            ),
            original_photo_url = "gs://photo.jpg"
        )

        whenever(repository.addNewItem(any(), any(), any(), any(), any())).thenReturn(
            AddNewItemResponse(success = true, item_id = "new_p1")
        )

        val viewModel = createViewModel(response)
        viewModel.addNewItem("pants", response.pants!!)
        advanceUntilIdle()

        assertTrue(viewModel.uiState.value.pantsHandled)
        assertNull(viewModel.uiState.value.error)
    }
}
```

## Test Coverage Summary

| Test Class | What It Tests | # Tests |
|-----------|---------------|---------|
| `ModelSerializationTest` | JSON ↔ model roundtrips, field names, null handling | 8 |
| `OutfitRepositoryTest` | API calls via MockWebServer, request/response bodies, errors | 5 |
| `CameraViewModelTest` | State transitions: idle → processing → result/error | 6 |
| `MatchConfirmationViewModelTest` | Nav arg parsing, confirm/add flow, isDone logic, errors | 5 |
| **Total** | | **24** |

## Edge Cases & Troubleshooting

| Issue | Solution |
|-------|----------|
| `Dispatchers.setMain` not working | Need `kotlinx-coroutines-test` dependency |
| MockWebServer `address already in use` | Ensure `tearDown()` calls `mockWebServer.shutdown()` |
| Mockito can't mock `suspend` functions | Use `mockito-kotlin` for proper suspend support |
| `ConfirmMatchResponse` field mismatch | Tests verify exact field names match backend JSON |
| Repository test with `@Url` | Pass MockWebServer URL directly; Retrofit handles it |

## Checklist

- [ ] `ModelSerializationTest.kt` created with tests for all 7 data classes:
  - [ ] `ProcessOutfitRequest` serialization
  - [ ] `ProcessOutfitResponse` deserialization (matched)
  - [ ] `ProcessOutfitResponse` deserialization (new item)
  - [ ] `ProcessOutfitResponse` deserialization (error)
  - [ ] `ConfirmMatchRequest` serialization with snake_case
  - [ ] `ConfirmMatchResponse` deserialization
  - [ ] `AddNewItemRequest` serialization
  - [ ] `AddNewItemResponse` deserialization
  - [ ] Roundtrip serialize → deserialize → equality check
- [ ] `OutfitRepositoryTest.kt` created:
  - [ ] `processOutfit` success with MockWebServer
  - [ ] `confirmMatch` returns wear count
  - [ ] `addNewItem` returns item ID
  - [ ] Server error (500) throws exception
  - [ ] Request body contains correct JSON
- [ ] `CameraViewModelTest.kt` created:
  - [ ] Initial state is idle
  - [ ] `processOutfit` sets `isProcessing`
  - [ ] Success sets `result`
  - [ ] Failure sets `error`
  - [ ] `setError` / `clearError` work
- [ ] `MatchConfirmationViewModelTest.kt` created:
  - [ ] Initializes from nav argument JSON
  - [ ] `isDone` when no items detected
  - [ ] `isDone` after handling both items
  - [ ] Error state on confirm failure
  - [ ] `addNewItem` calls repository correctly
- [ ] `./gradlew test` → ALL TESTS PASS
- [ ] Test report generated at `app/build/reports/tests/testDebugUnitTest/`
- [ ] No flaky tests (run twice to verify)

## Validation Commands

```bash
cd c:/Users/dolev/Downloads/personal/uniform_distribution/android

# 1. Run all unit tests
./gradlew test 2>&1 | tail -20
# Expected: "BUILD SUCCESSFUL" with all tests passing

# 2. Run specific test class
./gradlew test --tests "com.uniformdist.app.data.model.ModelSerializationTest" 2>&1 | tail -10

# 3. Run with verbose output
./gradlew test --info 2>&1 | grep -E "PASSED|FAILED|SKIPPED"
# Expected: all PASSED, none FAILED

# 4. Check test count
./gradlew test 2>&1 | grep -E "tests"
# Expected: "24 tests" or similar

# 5. View HTML test report (path)
echo "Test report: android/app/build/reports/tests/testDebugUnitTest/index.html"
```
